/*Author: Erich MacLean
CIS2430-0209
Title: Assignment 3
Project Folder: 
	Main and Classes:
		Assignment3.java
		EStoreSearch.java
		Product.java
		Book.java
		Electronic.java
 
	JUnit: 
		a3Test.java

	Sample Data:
		data.txt
Due: November 9th, 2020, 11:59pm
Submitted: November 8th, 2020, 1:15pm*/
package eStoreSearch;//assignment 3 package

import java.util.ArrayList;//import tools for list and mapping
import java.util.HashMap;//Imports hashamp as directory for mapping the search key words to their product

/**EStoreSearch class manages the array list of products as well as the directory for the descriptions
Fields:
String arraylist store is the list of all the unqiue products
string integerarray list hashmap is the directory that maps the strings to an array list of integers. The ints are the indexes at which the product appears in the arraylist store*/
class EStoreSearch{//create the store class
	private ArrayList<Product> store;//product array list to store the user added products
	private HashMap<String,ArrayList<Integer>> keys;//hashmap:  key word -> integer array list (indecies of products in the store that contains the key word in the description)

	/**EStoreSearch is the constructor method for the class
	@return nothing*/
	public EStoreSearch (){//constructor class for the store
		this.store = new ArrayList<Product>();//declare the map and list to a new map/list
		this.keys = new HashMap<String,ArrayList<Integer>>();
	}

	/**checkID takes a single id and compares it with all products in the list
	@param integer product id to find in the list
	@return integer index of a found id. return -1 by default*/
	public int checkID(int idToFind){//takes an id and uses the product compare id to determine the index of a matching id
		for(int i = 0;i < (this.store).size();i++){//loop through the store list
			if(((this.store).get(i)).compareID(idToFind,false)){//compare the id (false will compare normally)
				return i;//return the current position of the match in the list
			}
		}
		return -1;//return -1 by default
	}

	/**getSize returns the size of the store
	@return size of the store*/
	public int getSize(){
		return store.size();
	}

	/**addProduct is an overloaded method that takes the fields for a new product to be added to the store list.
	This addProduct adds a new electronic because it has only 5 parameters
	@param idIn integer product id to add
	@param descIn string product description
	@param priceIn double product price
	@param yearIn integer product year
	@param auhtorIn string is the book author field
	@param publishIn string is the book publisher field
	@return total size change of both store and map*/
	public int addProduct(int idIn,String descIn,double priceIn,int yearIn, String authorIn, String publishIn) throws Exception{//add product (book) takes all the book fields needed to create a new book
		if(checkID(idIn) != -1){
			throw new Exception("A product already exists with that id");
		}
		int prevSizes = (this.store).size() + (this.keys).size();
		addToMap(descIn,(this.store).size());//adds to map first (based on size of current store)
		(this.store).add(new Book("Book",idIn,descIn,priceIn,yearIn,authorIn,publishIn));//then add the book product to the list
		int afterSizes =  (this.store).size() + (this.keys).size();
		return (afterSizes - prevSizes);
	}

	/**addProduct is an overloaded method that takes the fields for a new product to be added to the store list.
	This addProduct adds a new electronic because it has only 5 parameters
	@param idIn integer product id to add
	@param descIn string product description
	@param priceIn double product price
	@param yearIn integer product year
	@param maker string electronic maker field
	@return total size change of both store and map*/
	public int addProduct(int idIn,String descIn,double priceIn,int yearIn, String maker) throws Exception{//add product (electronic) takes all the electronic based fields and adds it to the store list
		if(checkID(idIn) != -1){
			throw new Exception("A product already exists with that id\n");
		}
		int prevSizes = (this.store).size() + (this.keys).size();
		addToMap(descIn,(this.store).size());//add to map first (based on current length of store)
		(this.store).add(new Electronic("Electronic",idIn,descIn,priceIn,yearIn,maker));//add new electronic product to the list
		int afterSizes =  (this.store).size() + (this.keys).size();
		return (afterSizes - prevSizes);
	}

	/**printProducts will store all the product data in a string array to be printed out in main
	@return string array with all the product data*/
	public String[] printProducts(){//returns an array with the element strings generated by the toString method in products
		String [] storeStrings = new String[(this.store).size()];
		for(int i = 0;i < (this.store).size();i++){//loops through the store and gets the string data for each product
			storeStrings[i] = (((this.store).get(i)).toString(true));
		}
		return storeStrings;
	}

	/**printElement prints an existing product data, either to a file or the screen
	@param index is the index of the element to print
	@param toFile is the boolean to signal whether it is going to a file or not (summary line included or not)
	@return nothing*/
	public String printElement(int index,boolean toFile){//prints a single products data
		String returnableString = "";
		try{//avoids accessing something that is not in the list
			returnableString += (((this.store).get(index)).toString(toFile));//print product at given index
		}catch(IndexOutOfBoundsException e){//catch out of bounds error
			if(!toFile){
				returnableString += ("ERROR: The product at index " + index + " does not exist\n");//print error
			}
		}
		return returnableString;
	}

	/**addToMap adds a set of key words to the map if they are not on in the hashmap. If they are in the hash map, then it will add the current store size (index of a product that has that keyword) to its generated array list
	@param desc is a string that contains the description to split into key words
	@param currentStoreSize is the integer that gets added to the key word array list value
	@return size change*/
	public int addToMap (String desc,int currentStoreSize){//adds key words to key word map
		int prevSize = (this.keys).size();
		//System.out.println("Before size : " + (this.keys).size());
		desc = desc.toLowerCase();
		String [] keyWords = desc.split(" ");//split the words into an array of key words

		for(int w  = 0;w < keyWords.length;w++){//loop through the array of key words in the entered description 
			//keys.get(keyWords[w]) retrieves a location array list containing the index locations for that word
			try{
				if(freq((this.keys).get(keyWords[w]),currentStoreSize) == 0){
					((this.keys).get(keyWords[w])).add(currentStoreSize);//try to add the current size (index of the word in the product list) to its corresponding array list
				}
			}catch(NullPointerException e){//if the word is not in the hash map, it will put the word into the map as a keyword, array list pair, then add the current size of the product list
				(this.keys).put(keyWords[w],new ArrayList<Integer>());//add the key value pair to the hash map
				if(freq((this.keys).get(keyWords[w]),currentStoreSize) == 0){
					((this.keys).get(keyWords[w])).add(currentStoreSize);//try to add the current size (index of the word in the product list) to its corresponding array list
				}
			}
		}
		//System.out.println("After size : " + (this.keys).size());
		int difference = (this.keys).size() - prevSize;
		//System.out.println(difference);
		return difference;
	}

	/**printSearch prints out the results of the search with the given parameters
	@param desc is the description key word string to search by
	@param prodId is the search product id. default is -1
	@param yearsIn is the search integer array for the years
	@return voided. Prints product info based on search*/
	public String printSearch(String desc, int prodId,int[] yearsIn){//prints the results of search using the given parameters
		String printableSearch = "";
		ArrayList<Integer> results = search(desc,prodId,yearsIn);//performs a search
		if(results.size() == 0){//if no items were found, then none of the cases were matched (or they were all left blank)
			printableSearch += ("The store is empty or does not have that item on file\n");
		}else{
			for(int r = 0;r < results.size();r++){//loop through the results array list (array of indecies of products that matched the search parameters)
				printableSearch += "Search Result #" + (r+1) + "\n" + printElement(results.get(r),false);//call printElement on the element at the index IN the results array list. Not at r
			}
			printableSearch += "\n";
		}

		return printableSearch;
	}

	/**search generates a final array list of indexes that match given search parameters
	@param desc is the description key word string to search by
	@param prodId is the search product id. default is -1
	@param yearsIn is the search integer array for the years
	@return integer array list of all indexes of products that match the given search terms*/
	public ArrayList<Integer> search(String desc, int prodId,int[] yearsIn){//search for products based on given parameters. Gives arraylist of indecies of matching products back
		ArrayList<Integer> current = intersect(desc);//create the current set of indecies
		if(desc.length() > 0){//loop through the indexes flagged by the intersection function and check product id and year//This only happens if there is a description
			for(int i = current.size() -1;i >= 0;i--){//loop backwards and renmove anything that does not match the years or product id
				if(!(((this.store).get(current.get(i))).compareID(prodId,true) && ((this.store).get(current.get(i))).compareYear(yearsIn))){//compares the id and the year to the current product. Years search default is 1000-9999 and products defualt is -1 (true)
					current.remove(i);//if both results are matched, then do not remove the current index
				}
			}
		}else{//if the description was empty
			for(int i = 0;i < (this.store).size();i++){//loop through the store and add indexes to current depending on whether the product id and years are matched
				if(((this.store).get(i)).compareID(prodId,true) && ((this.store).get(i)).compareYear(yearsIn)){
					current.add(i);//add the products index
				}
			}
		}
		return current;//array list of indexes of products that matched the search parameters
	}

	/**intersect determines which elements in the store list match the search key words
	makes a large concatenation of the array lists for each given key word and then sequentially removes them to determine the number of appearances of each index/word pair
	@param desc is the description key word string generated by the user
	@return integer arraylist where integers represent indexes of the product locations that match the key word descriptions*/
	public ArrayList<Integer> intersect (String desc){//return an integer array list with the locations of products where all search words were matched
		desc = desc.toLowerCase();//conver thte string to lowercase
		String [] words = desc.split(" ");//split the description search into an array

		ArrayList<Integer> allLocations = new ArrayList<Integer>();//list of all word locations. eg: this 1 2 4, book 1 4 5--> 1 2 4 1 4 5

		for(int w = 0;w < words.length;w++){//loop through the word list and get the array list integer for the word to the allLocations list
			if((this.keys).containsKey(words[w])){//if the word is in the hashmap
				for(int p = 0;p < (keys.get(words[w]).size());p++){//loop through the integer positions for the corresponding word
					allLocations.add((keys.get(words[w])).get(p));//add it to the allLocations list
				}
			}
		}
		//System.out.println("Intersections");
		ArrayList<Integer> intersections = new ArrayList<Integer>();//create a new integer array list for the intersections

		for(int j = 0;j < allLocations.size();j++){//loop through the all location arraylist
			if(freq(intersections,allLocations.get(j)) == 0){//if the current number is not currently in the array list is not currently in the array list
				if(freq(allLocations,allLocations.get(j)) == words.length){//if the number of times an index position appeared in the list matches the number of search terms, then the product at that location matched all of the search terms and should be returned
					//System.out.println(allLocations.get(j));
					intersections.add(allLocations.get(j));
				}
			}
		}

		//System.out.println(intersections.size());
		return intersections;//return the array list of indexes
	}

	/**determine the frequency of an integer in a given integer arraylist
	@param intList is the integer array list to look through
	@param item is the integer to count the number of appearances
	@return the counted frequency of the item in the intList*/
	public int freq(ArrayList<Integer> intList,int item){
		int count = 0;
		for(int i = 0;i < intList.size();i++){//loop through arrayList
			if(item == intList.get(i)){//if match found, increase count
				count++;
			}
		}
		return count;
	}

}
